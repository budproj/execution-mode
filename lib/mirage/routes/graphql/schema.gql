# Defines the resource policies for a given node. You can use it to build read/update/delete logic on your application
type NodePolicy {
  read: Effect!
  update: Effect!
  delete: Effect!
}

# Defines if the current user has the permission for a given action regarding the resource
enum Effect {
  ALLOW
  DENY
}

# A workspace is basically a team that has no parents
type Workspace implements NodeInterface & GuardedNodeInterface {
  # The ID of this node
  id: ID!

  # The creation date of the entity
  createdAt: DateTime!
  policy: NodePolicy!
}

# A node represents an unit in our edge list
interface NodeInterface {
  # The ID of this node
  id: ID!

  # The creation date of the entity
  createdAt: DateTime!
}

# A date-time string at UTC, such as 2019-12-03T09:54:33Z, compliant with the date-time format.
scalar DateTime

# A guarded node is like a common node, but with an extra policy field
interface GuardedNodeInterface implements NodeInterface {
  # The ID of this node
  id: ID!

  # The creation date of the entity
  createdAt: DateTime!
  policy: NodePolicy!
}

# Defines the resource policies for a given resource. You can use it to build create/read/update/delete logic on your application
type ResourcePolicy {
  create: Effect!
  read: Effect!
  update: Effect!
  delete: Effect!
}

# Defines all user permissions for each entity in our domain
type Permissions {
  user: ResourcePolicy!
  team: ResourcePolicy!
  cycle: ResourcePolicy!
  objective: ResourcePolicy!
  keyResult: ResourcePolicy!
  keyResultCheckIn: ResourcePolicy!
  keyResultComment: ResourcePolicy!
  keyResultCustomList: ResourcePolicy!
  workspace: ResourcePolicy!
}

# Defines the resource policy for a given connection. You can use it to build create access logic on your application
type ConnectionPolicy {
  create: Effect!
}

# This object contains information regarding the pagination of a given node list
type PageInfo {
  # If there is a next page, this key is set to true
  hasNextPage: Boolean!

  # If there is a previous page, this key is set to true
  hasPreviousPage: Boolean!

  # The cursor ID of the first element in our nodes list
  startCursor: String

  # The cursor ID of the last element in our nodes list
  endCursor: String
}

# A setting is a record that customizes a given user preferences
type UserSetting implements NodeInterface & GuardedNodeInterface {
  # The ID of this node
  id: ID!

  # The creation date of the entity
  createdAt: DateTime!
  policy: NodePolicy!

  # The key of the setting
  key: UserSettingKey!

  # The value of this setting
  value: String!

  # The ID of the user attached to this setting
  userId: ID!

  # The user attached to this setting
  user: User!
}

# The key of a given setting for a user
enum UserSettingKey {
  LOCALE
}

# This edge represents the relation between users and their settings
type UserSettingEdge implements EdgeInterface {
  # The cursor value of this node
  cursor: String
  node: UserSetting!
}

# An edge is used for proper pagination in nodes
interface EdgeInterface {
  # The cursor value of this node
  cursor: String
}

# A list containing a given user settings based on the provided filters and arguments
type UserSettingsConnection implements ConnectionInterface & GuardedConnectionInterface {
  pageInfo: PageInfo!
  parentNodeId: ID!
  policy: ConnectionPolicy!
  edges: [UserSettingEdge!]!
}

# This interface wraps all list connections from our schema
interface ConnectionInterface {
  pageInfo: PageInfo!
  parentNodeId: ID!
}

# A guarded connection is like a common connection, but with an extra policy field
interface GuardedConnectionInterface implements ConnectionInterface {
  pageInfo: PageInfo!
  parentNodeId: ID!
  policy: ConnectionPolicy!
}

# The delta of an entity. In this key you're going to find the difference bet this entity and a given previous snapshot of it
type Delta {
  # The progress difference of this entity comparing with it last week
  progress: Float!

  # The confidence difference of this entity comparing with it last week
  confidence: Int!
}

# The delta of a key-result check-in. This key contains the difference between a given check-in and it's parent
type KeyResultCheckInDelta {
  # The progress difference of this entity comparing with it last week
  progress: Float!

  # The confidence difference of this entity comparing with it last week
  confidence: Int!

  # The value increase comparing to previous check-in
  value: Float!
}

# This edge represents the relation between objectives and their support teams
type ObjectiveTeamEdge implements EdgeInterface {
  # The cursor value of this node
  cursor: String
  node: Team!
}

# A list containing a given objective support teams based on the provided filters and arguments
type ObjectiveTeamsConnection implements ConnectionInterface & GuardedConnectionInterface {
  pageInfo: PageInfo!
  parentNodeId: ID!
  policy: ConnectionPolicy!
  edges: [ObjectiveTeamEdge!]!
}

# The current status of an entity. By status we mean progress, confidence, and other reported values from it's children
type Status {
  # The computed percentage current progress of this entity. The entity progress calculation vary based on the entity
  progress: Float!

  # The computed current confidence of this entity. The confidence is always the lowest among the entity's children
  confidence: Int!

  # This key defines if the given entity is active. An active entity definition varies according to the entity
  isActive: Boolean!

  # This key defines if the given entity is outdated. By outdated we mean that it needs to receive a new report
  isOutdated: Boolean!

  # The latest check-in date in this status
  reportDate: DateTime

  # The latest check-in date in this status
  latestCheckIn: KeyResultCheckIn
}

# This edge represents the relation between objectives and their key-results
type ObjectiveKeyResultEdge implements EdgeInterface {
  # The cursor value of this node
  cursor: String
  node: KeyResult!
}

# A list containing a given user key-results based on the provided filters and arguments
type ObjectiveKeyResultsConnection implements ConnectionInterface & GuardedConnectionInterface {
  pageInfo: PageInfo!
  parentNodeId: ID!
  policy: ConnectionPolicy!
  edges: [ObjectiveKeyResultEdge!]!
}

# The current status of this objective. By status we mean progress, confidence, and other reported values from it
type Objective implements NodeInterface & GuardedNodeInterface {
  # The ID of this node
  id: ID!

  # The creation date of the entity
  createdAt: DateTime!
  policy: NodePolicy!

  # The title of the objective
  title: String!

  # The last update date of the objective
  updatedAt: DateTime!

  # The cycle ID that owns this objective
  cycleId: ID!

  # The team ID that owns this objective
  teamId: ID

  # The user ID that owns this objective
  ownerId: ID!
  status(
    # Defines until with date we should look to define the status
    date: DateTime
  ): Status!
  delta: Delta!
  cycle: Cycle!
  owner: User!
  team: Team
  keyResults(
    # The ID of the node you want to filter in your query
    id: ID

    # Define the expected order for our key-result edges
    order: DefaultOrderInput = { createdAt: ASC }

    # Paginate first
    first: Int = 20

    # Paginate last
    last: Int

    # Paginate after opaque cursor
    after: String

    # Paginate before opaque cursor
    before: String

    # The user ID that should owns the key results you are trying to fetch
    ownerId: ID
  ): ObjectiveKeyResultsConnection
  supportTeams(
    # The ID of the node you want to filter in your query
    id: ID

    # Define the expected order for our connection edges
    order: DefaultOrderInput = { createdAt: DESC }

    # Paginate first
    first: Int = 20

    # Paginate last
    last: Int

    # Paginate after opaque cursor
    after: String

    # Paginate before opaque cursor
    before: String

    # The ID of the parent team that you want to user on this query
    parentId: ID

    # Defines the level of the team you want to query
    level: TeamType
  ): ObjectiveTeamsConnection
}

# Defines the default expected order for a given entity
input DefaultOrderInput {
  # Defines the expected order for the createdAt attribute
  createdAt: Sorting
}

# Defines the order to return your results in a given query
enum Sorting {
  DESC
  ASC
}

# Define the level of the team in the hierarchy
enum TeamType {
  COMPANY
  COMPANY_OR_DEPARTMENT
}

# The edge for our key-result query interface
type KeyResultKeyResultCheckInEdge implements EdgeInterface {
  # The cursor value of this node
  cursor: String
  node: KeyResultCheckIn!
}

# A list containing key-results based on the provided filters and arguments
type KeyResultKeyResultCheckInsConnection implements ConnectionInterface & GuardedConnectionInterface {
  pageInfo: PageInfo!
  parentNodeId: ID!
  policy: ConnectionPolicy!
  edges: [KeyResultKeyResultCheckInEdge!]!
}

# A check mark in a given key result
type KeyResultCheckMark implements NodeInterface & GuardedNodeInterface {
  # The ID of this node
  id: ID!

  # The creation date of the entity
  createdAt: DateTime!
  policy: NodePolicy!

  # The state of check mark
  state: String!

  # The text description of a check mark
  description: String!

  # last time the check mark was updated
  updatedAt: DateTime!

  # The ID of the key result this check mark belongs to
  keyResultId: ID!

  # The ID of the user who created this check mark
  userId: ID!

  # The ID of the user this check mark is assigned to
  assignedUserId: ID!

  # The key result that this check mark relates to
  keyResult: KeyResult!

  # The user that created this check mark
  user: User!
  assignedUser: User!
}

# The edge for our key-result query interface
type KeyResultKeyResultCheckMarkEdge implements EdgeInterface {
  # The cursor value of this node
  cursor: String
  node: KeyResultCheckMark!
}

# An object containing information about how many check items are checked in a checklist
type CheckMarkProgress {
  numberOfChecked: Float!
  progress: Float!
  total: Float!
}

# A list containing key-results check marks based on the provided filters and arguments
type KeyResultKeyResultCheckListConnection implements ConnectionInterface & GuardedConnectionInterface {
  pageInfo: PageInfo!
  parentNodeId: ID!
  policy: ConnectionPolicy!
  edges: [KeyResultKeyResultCheckMarkEdge!]!
  progress: CheckMarkProgress!
}

# A comment in a given key result
type KeyResultComment implements NodeInterface & GuardedNodeInterface {
  # The ID of this node
  id: ID!

  # The creation date of the entity
  createdAt: DateTime!
  policy: NodePolicy!

  # The text of the comment
  text: String!

  # The last update date of the comment
  updatedAt: DateTime!

  # The key result ID that this comment is related to
  keyResultId: ID!

  # The user ID that owns this comment
  userId: ID!
  keyResult: KeyResult!
  user: User!
}

# The edge for our key-result query interface
type KeyResultKeyResultCommentEdge implements EdgeInterface {
  # The cursor value of this node
  cursor: String
  node: KeyResultComment!
}

# A list containing key-results based on the provided filters and arguments
type KeyResultKeyResultCommentsConnection implements ConnectionInterface & GuardedConnectionInterface {
  pageInfo: PageInfo!
  parentNodeId: ID!
  policy: ConnectionPolicy!
  edges: [KeyResultKeyResultCommentEdge!]!
}

# The edge for our users support team query interface
type KeyResultKeyResultSupportTeamEdge implements EdgeInterface {
  # The cursor value of this node
  cursor: String
  node: User!
}

# A list containing users support team based on the provided filters and arguments
type KeyResultKeyResultSupportTeamConnection implements ConnectionInterface & GuardedConnectionInterface {
  pageInfo: PageInfo!
  parentNodeId: ID!
  policy: ConnectionPolicy!
  edges: [KeyResultKeyResultSupportTeamEdge!]!
}

# This object represents a progress record for a given key-result
type KeyResultProgressRecord implements NodeInterface {
  # The ID of this node
  id: ID!

  # The creation date of the entity
  createdAt: DateTime!

  # The update date of the progress record
  updatedAt: DateTime!

  # The progress of this record
  progress: Float!

  # The ID of the key-result associated to this progress record
  keyResultId: ID!

  # The ID of the key-result check-in associated to this progress record
  keyResultCheckInId: ID!

  # The date of the progress record report
  date: DateTime!
  keyResultCheckIn: KeyResultCheckIn!
  keyResult: KeyResult!
}

# The edge for our key-result progress history query interface
type KeyResultProgressHistoryEdge implements EdgeInterface {
  # The cursor value of this node
  cursor: String
  node: KeyResultProgressRecord!
}

# A list containing key-result progress records based on the provided filters and arguments
type KeyResultProgressHistoryConnectionConnection implements ConnectionInterface & GuardedConnectionInterface {
  pageInfo: PageInfo!
  parentNodeId: ID!
  policy: ConnectionPolicy!
  edges: [KeyResultProgressHistoryEdge!]!
}

# The edge for our key-result timeline query interface
type KeyResultTimelineEdge implements EdgeInterface {
  # The cursor value of this node
  cursor: String
  node: KeyResultTimelineEntryUnion!
}

union KeyResultTimelineEntryUnion = KeyResultCheckIn | KeyResultComment

# A list with a given key-result timeline based on the provided filters and arguments
type KeyResultTimelineConnection implements ConnectionInterface & GuardedConnectionInterface {
  pageInfo: PageInfo!
  parentNodeId: ID!
  policy: ConnectionPolicy!
  edges: [KeyResultTimelineEdge!]!
}

# A key-result is a given goal inside an objective
type KeyResult implements NodeInterface & GuardedNodeInterface {
  # The ID of this node
  id: ID!

  # The creation date of the entity
  createdAt: DateTime!
  policy: NodePolicy!

  # The title of the key result
  title: String!

  # The initial value of the key result
  initialValue: Float!

  # The goal of the key result
  goal: Float!

  # The format of the key result
  format: KeyResultFormat!

  # The type of the key result
  type: KeyResultType!

  # The last update date of the key result
  updatedAt: DateTime!

  # The owner ID of the key result
  ownerId: ID!

  # The object ID that this key result belongs to
  objectiveId: ID!

  # The team ID that this key result belongs to
  teamId: ID

  # The description explaining the key result
  description: String
  owner: User!
  objective: Objective!
  team: Team!
  status(
    # Defines until with date we should look to define the status
    date: DateTime
  ): Status!
  delta: Delta!
  supportTeamMembers(
    # The ID of the node you want to filter in your query
    id: ID

    # Define the expected order for our key-result edges
    order: DefaultOrderInput = { createdAt: ASC }

    # Paginate first
    first: Int = 20

    # Paginate last
    last: Int

    # Paginate after opaque cursor
    after: String

    # Paginate before opaque cursor
    before: String
  ): KeyResultKeyResultSupportTeamConnection!
  keyResultComments(
    # The ID of the node you want to filter in your query
    id: ID

    # Define the expected order for our connection edges
    order: DefaultOrderInput = { createdAt: DESC }

    # Paginate first
    first: Int = 20

    # Paginate last
    last: Int

    # Paginate after opaque cursor
    after: String

    # Paginate before opaque cursor
    before: String

    # Fetches key-result comments from a given user
    userId: ID
  ): KeyResultKeyResultCommentsConnection!
  keyResultCheckIns(
    # The ID of the node you want to filter in your query
    id: ID

    # Define the expected order for our connection edges
    order: DefaultOrderInput = { createdAt: DESC }

    # Paginate first
    first: Int = 20

    # Paginate last
    last: Int

    # Paginate after opaque cursor
    after: String

    # Paginate before opaque cursor
    before: String

    # Fetches key-result comments from a given user
    userId: ID
  ): KeyResultKeyResultCheckInsConnection!
  timeline(
    # Paginate first
    first: Int = 20

    # Paginate last
    last: Int

    # Paginate after opaque cursor
    after: String

    # Paginate before opaque cursor
    before: String

    # The ID of the node you want to filter in your query
    id: ID

    # Define the expected order for our connection edges
    order: DefaultOrderInput = { createdAt: DESC }
  ): KeyResultTimelineConnection!
  checkList(
    # The ID of the node you want to filter in your query
    id: ID

    # Define the expected order for our connection edges
    order: DefaultOrderInput = { createdAt: DESC }

    # Paginate first
    first: Int = 20

    # Paginate last
    last: Int

    # Paginate after opaque cursor
    after: String

    # Paginate before opaque cursor
    before: String

    # Fetches key-result checklist created by a given user
    userId: ID

    # If true, show only check marks assigned to the user
    onlyAssignedToMe: Boolean = false
  ): KeyResultKeyResultCheckListConnection!
  progressHistory(
    # Paginate first
    first: Int = 20

    # Paginate last
    last: Int

    # Paginate after opaque cursor
    after: String

    # Paginate before opaque cursor
    before: String

    # The ID of the node you want to filter in your query
    id: ID

    # Define the expected order for our connection edges
    order: DefaultOrderInput = { createdAt: DESC }
  ): KeyResultProgressHistoryConnectionConnection!
}

# Each format represents how our user wants to see the metrics of the key result
enum KeyResultFormat {
  NUMBER
  PERCENTAGE
  COIN_BRL
  COIN_USD
}

# It represents the type of check-ins attached for this key result
enum KeyResultType {
  ASCENDING
  DESCENDING
}

# A report in a given key result
type KeyResultCheckIn implements NodeInterface & GuardedNodeInterface {
  # The ID of this node
  id: ID!

  # The creation date of the entity
  createdAt: DateTime!
  policy: NodePolicy!

  # The reported value in this check-in
  value: Float!

  # The reported confidence in this check-in
  confidence: Int!

  # The key result ID that this report is related to
  keyResultId: ID!

  # The user ID that owns this report
  userId: ID!

  # The comment added in the report
  comment: String
  progress: Float!
  keyResult: KeyResult!
  user: User!
  delta: KeyResultCheckInDelta!
  parent: KeyResultCheckIn
}

# This edge represents the relation between users and their key-results
type UserKeyResultCheckInEdge implements EdgeInterface {
  # The cursor value of this node
  cursor: String
  node: KeyResultCheckIn!
}

# A list containing a given user key-results based on the provided filters and arguments
type UserKeyResultCheckInsConnection implements ConnectionInterface & GuardedConnectionInterface {
  pageInfo: PageInfo!
  parentNodeId: ID!
  policy: ConnectionPolicy!
  edges: [UserKeyResultCheckInEdge!]!
}

# This edge represents the relation between users and their key-results
type UserKeyResultCommentEdge implements EdgeInterface {
  # The cursor value of this node
  cursor: String
  node: KeyResultComment!
}

# A list containing a given user key-results based on the provided filters and arguments
type UserKeyResultCommentsConnection implements ConnectionInterface & GuardedConnectionInterface {
  pageInfo: PageInfo!
  parentNodeId: ID!
  policy: ConnectionPolicy!
  edges: [UserKeyResultCommentEdge!]!
}

# This edge represents the relation between users and their key-results
type UserKeyResultEdge implements EdgeInterface {
  # The cursor value of this node
  cursor: String
  node: KeyResult!
}

# A list containing a given user key-results based on the provided filters and arguments
type UserKeyResultsConnection implements ConnectionInterface & GuardedConnectionInterface {
  pageInfo: PageInfo!
  parentNodeId: ID!
  policy: ConnectionPolicy!
  edges: [UserKeyResultEdge!]!
}

# This edge represents the relation between users and their objectives
type UserObjectiveEdge implements EdgeInterface {
  # The cursor value of this node
  cursor: String
  node: Objective!
}

# A list containing a given user objectives based on the provided filters and arguments
type UserObjectivesConnection implements ConnectionInterface & GuardedConnectionInterface {
  pageInfo: PageInfo!
  parentNodeId: ID!
  policy: ConnectionPolicy!
  edges: [UserObjectiveEdge!]!
}

# Task is an entity inside a given user. It is used by the user to organize his/her day.
type Task implements NodeInterface & GuardedNodeInterface {
  # The ID of this node
  id: ID!

  # The creation date of the entity
  createdAt: DateTime!
  policy: NodePolicy!

  # The state of the task
  state: String!

  # The text description of the task
  description: String!

  # The ID of the user who the task is assigned to
  assignedUserId: ID!

  # The user this task is assigned to
  assignedUser: User!
}

# This edge represents the relation between users and their key-results
type UserTasksEdge implements EdgeInterface {
  # The cursor value of this node
  cursor: String
  node: Task!
}

# A list containing a given user tasks based on the provided filters and arguments
type UserTasksConnection implements ConnectionInterface & GuardedConnectionInterface {
  pageInfo: PageInfo!
  parentNodeId: ID!
  policy: ConnectionPolicy!
  edges: [UserTasksEdge!]!
}

# This edge represents the relation between users and their teams
type UserTeamEdge implements EdgeInterface {
  # The cursor value of this node
  cursor: String
  node: Team!
}

# A list containing a given user teams based on the provided filters and arguments
type UserTeamsConnection implements ConnectionInterface & GuardedConnectionInterface {
  pageInfo: PageInfo!
  parentNodeId: ID!
  policy: ConnectionPolicy!
  edges: [UserTeamEdge!]!
  quantities: QuantityNode!
}

# User is an entity inside a given root team (a.k.a. company). It is associated with many teams, progress reports, and others.
type User implements NodeInterface & GuardedNodeInterface {
  # The ID of this node
  id: ID!

  # The creation date of the entity
  createdAt: DateTime!
  policy: NodePolicy!

  # The name of the user
  firstName: String!

  # The user e-mail
  email: String!

  # The status of this user
  status: UserStatus!

  # The sub field in Auth0 (their ID)
  authzSub: String!

  # The last update date of this user
  updatedAt: DateTime!

  # The last name of the user
  lastName: String

  # The gender of the user
  gender: UserGender

  # The user role in the company
  role: String

  # The picture of the user
  picture: String

  # The custom nickname that user wants to be called
  nickname: String

  # A description for that user. A more detailed information where the user tells about her/himself
  about: String

  # The URL for the user's LinkedIn profile
  linkedInProfileAddress: String
  fullName: String!
  companies(
    # The ID of the node you want to filter in your query
    id: ID

    # Define the expected order for our connection edges
    order: DefaultOrderInput = { createdAt: DESC }

    # Paginate first
    first: Int = 20

    # Paginate last
    last: Int

    # Paginate after opaque cursor
    after: String

    # Paginate before opaque cursor
    before: String

    # The ID of the parent team that you want to user on this query
    parentId: ID

    # Defines the level of the team you want to query
    level: TeamType
  ): UserTeamsConnection
  teams(
    # The ID of the node you want to filter in your query
    id: ID

    # Define the expected order for our connection edges
    order: DefaultOrderInput = { createdAt: DESC }

    # Paginate first
    first: Int = 20

    # Paginate last
    last: Int

    # Paginate after opaque cursor
    after: String

    # Paginate before opaque cursor
    before: String

    # The ID of the parent team that you want to user on this query
    parentId: ID

    # Defines the level of the team you want to query
    level: TeamType
  ): UserTeamsConnection
  ownedTeams(
    # The ID of the node you want to filter in your query
    id: ID

    # Define the expected order for our connection edges
    order: DefaultOrderInput = { createdAt: DESC }

    # Paginate first
    first: Int = 20

    # Paginate last
    last: Int

    # Paginate after opaque cursor
    after: String

    # Paginate before opaque cursor
    before: String

    # The ID of the parent team that you want to user on this query
    parentId: ID

    # Defines the level of the team you want to query
    level: TeamType
  ): UserTeamsConnection
  objectives(
    # The ID of the node you want to filter in your query
    id: ID

    # Define the expected order for our connection edges
    order: DefaultOrderInput = { createdAt: DESC }

    # Paginate first
    first: Int = 20

    # Paginate last
    last: Int

    # Paginate after opaque cursor
    after: String

    # Paginate before opaque cursor
    before: String

    # If you set this argument to true or false it will only fetch active or non-active objectives. Leave it null if you want both
    active: Boolean

    # If you set this argument to a user id, it will fetch its objectives. Leave null if you want all objectives.
    ownerId: ID

    # If you set this argument with a team id, it will fetch team related objectives. Leave null if you want all goals or set the id to null if you want objectives without team id.
    teamId: ID
  ): UserObjectivesConnection
  keyResults(
    # The user ID that should owns the key results you are trying to fetch
    ownerId: ID

    # Define the expected order for our connection edges
    order: DefaultOrderInput = { createdAt: DESC }

    # The ID of the node you want to filter in your query
    id: ID

    # Paginate first
    first: Int = 20

    # Paginate last
    last: Int

    # Paginate after opaque cursor
    after: String

    # Paginate before opaque cursor
    before: String

    # A flag that defines if we should fetch only active key-results for this user
    active: Boolean = true

    # A flag that defines if we should fetch only key-results that contains checkmarks of this user
    hasUserCheckMarks: Boolean

    # Define the confidence of the key results
    confidence: String

    # A flag that defines if we should fetch only key-results from a company
    onlyKeyResultsFromCompany: Boolean
  ): UserKeyResultsConnection
  keyResultComments(
    # The ID of the node you want to filter in your query
    id: ID

    # Define the expected order for our connection edges
    order: DefaultOrderInput = { createdAt: DESC }

    # Paginate first
    first: Int = 20

    # Paginate last
    last: Int

    # Paginate after opaque cursor
    after: String

    # Paginate before opaque cursor
    before: String

    # Fetches key-result comments from a given user
    userId: ID
  ): UserKeyResultCommentsConnection
  keyResultCheckIns(
    # The ID of the node you want to filter in your query
    id: ID

    # Define the expected order for our connection edges
    order: DefaultOrderInput = { createdAt: DESC }

    # Paginate first
    first: Int = 20

    # Paginate last
    last: Int

    # Paginate after opaque cursor
    after: String

    # Paginate before opaque cursor
    before: String

    # Fetches key-result comments from a given user
    userId: ID
  ): UserKeyResultCheckInsConnection
  tasks(
    # The ID of the node you want to filter in your query
    id: ID

    # Define the expected order for our connection edges
    order: DefaultOrderInput = { createdAt: DESC }

    # Paginate first
    first: Int = 20

    # Paginate last
    last: Int

    # Paginate after opaque cursor
    after: String

    # Paginate before opaque cursor
    before: String

    # A filter to query only tasks that are completed
    onlyUnchecked: Boolean = false
  ): UserTasksConnection
  settings(
    # The ID of the node you want to filter in your query
    id: ID

    # Define the expected order for our connection edges
    order: DefaultOrderInput = { createdAt: DESC }

    # Paginate first
    first: Int = 20

    # Paginate last
    last: Int

    # Paginate after opaque cursor
    after: String

    # Paginate before opaque cursor
    before: String

    # A specific key you want to query from user settings
    keys: [UserSettingKey!]
  ): UserSettingsConnection
  authzRole: UserRoleObject!
  quarterlyProgress: UserReportProgressObject
  yearlyProgress: UserReportProgressObject
}

# Each status represents a status for our users
enum UserStatus {
  ACTIVE
  INACTIVE
}

# Each gender represents a possible gender option for our users
enum UserGender {
  MALE
  FEMALE
}

# This edge represents the relation between teams and their cycles
type TeamCycleEdge implements EdgeInterface {
  # The cursor value of this node
  cursor: String
  node: Cycle!
}

# A list containing a given user key-results based on the provided filters and arguments
type TeamCyclesConnection implements ConnectionInterface & GuardedConnectionInterface {
  pageInfo: PageInfo!
  parentNodeId: ID!
  policy: ConnectionPolicy!
  edges: [TeamCycleEdge!]!
}

# This edge represents the relation between teams and their key-results
type TeamKeyResultEdge implements EdgeInterface {
  # The cursor value of this node
  cursor: String
  node: KeyResult!
}

# A list containing a given user key-results based on the provided filters and arguments
type TeamKeyResultsConnection implements ConnectionInterface & GuardedConnectionInterface {
  pageInfo: PageInfo!
  parentNodeId: ID!
  policy: ConnectionPolicy!
  edges: [TeamKeyResultEdge!]!
}

# This edge represents the relation between teams and their objectives
type TeamObjectiveEdge implements EdgeInterface {
  # The cursor value of this node
  cursor: String
  node: Objective!
}

# A list containing a given user key-results based on the provided filters and arguments
type TeamObjectivesConnection implements ConnectionInterface & GuardedConnectionInterface {
  pageInfo: PageInfo!
  parentNodeId: ID!
  policy: ConnectionPolicy!
  edges: [TeamObjectiveEdge!]!
}

# This edge represents the relation between teams and their users
type TeamTeamEdge implements EdgeInterface {
  # The cursor value of this node
  cursor: String
  node: Team!
}

# A list containing a given team key-results based on the provided filters and arguments
type TeamTeamsConnection implements ConnectionInterface & GuardedConnectionInterface {
  pageInfo: PageInfo!
  parentNodeId: ID!
  policy: ConnectionPolicy!
  edges: [TeamTeamEdge!]!
}

# This edge represents the relation between teams and their users
type TeamUserEdge implements EdgeInterface {
  # The cursor value of this node
  cursor: String
  node: User!
}

# A list containing a given user key-results based on the provided filters and arguments
type TeamUsersConnection implements ConnectionInterface & GuardedConnectionInterface {
  pageInfo: PageInfo!
  parentNodeId: ID!
  policy: ConnectionPolicy!
  edges: [TeamUserEdge!]!
}

# A collection of users. It can be either inside another team, or a root team (a.k.a. company)
type Team implements NodeInterface & GuardedNodeInterface {
  # The ID of this node
  id: ID!

  # The creation date of the entity
  createdAt: DateTime!
  policy: NodePolicy!

  # The name of the team
  name: String!

  # The last update date of the team
  updatedAt: DateTime!

  # The user ID that owns this team
  ownerId: ID!

  # The description about the team
  description: String

  # The gender of the team
  gender: TeamGender

  # The ID of the team that owns this team
  parentId: ID
  status(
    # Defines until with date we should look to define the status
    date: DateTime

    # Defines our cycle filters to use while fetching this team status
    cycleFilters: CycleAttributesInput = { active: true }
  ): Status!
  delta(
    # Defines until with date we should look to define the status
    date: DateTime

    # Defines our cycle filters to use while fetching this team status
    cycleFilters: CycleAttributesInput = { active: true }
  ): Delta!
  owner: User!
  isCompany: Boolean!

  # The team that is the company of this team. This is also known as "rootTeam"
  company: Team
  parent: Team
  tacticalCycle: Cycle
  users(
    # Define the expected order for our users connection edges
    order: UserOrderInput = { firstName: ASC }

    # Define if the query should return only users with individual objectives
    onlyWithIndividualObjectives: Boolean

    # Define if the query should return only active users or not
    withInactives: Boolean

    # The ID of the node you want to filter in your query
    id: ID

    # Paginate first
    first: Int = 20

    # Paginate last
    last: Int

    # Paginate after opaque cursor
    after: String

    # Paginate before opaque cursor
    before: String

    # Define if we should resolve the entire team tree, showing all users below that team and subteams
    resolveTree: Boolean = true
  ): TeamUsersConnection
  teams(
    # The ID of the node you want to filter in your query
    id: ID

    # Define the expected order for our connection edges
    order: DefaultOrderInput = { createdAt: DESC }

    # Paginate first
    first: Int = 20

    # Paginate last
    last: Int

    # Paginate after opaque cursor
    after: String

    # Paginate before opaque cursor
    before: String

    # The ID of the parent team that you want to user on this query
    parentId: ID

    # Defines the level of the team you want to query
    level: TeamType
  ): TeamTeamsConnection
  rankedDescendants(
    # The ID of the node you want to filter in your query
    id: ID

    # Define the expected order for our connection edges
    order: DefaultOrderInput = { createdAt: DESC }

    # Paginate first
    first: Int = 20

    # Paginate last
    last: Int

    # Paginate after opaque cursor
    after: String

    # Paginate before opaque cursor
    before: String

    # The ID of the parent team that you want to user on this query
    parentId: ID

    # Defines the level of the team you want to query
    level: TeamType
  ): TeamTeamsConnection
  cycles(
    # The ID of the node you want to filter in your query
    id: ID

    # Define the expected order for our connection edges
    order: DefaultOrderInput = { createdAt: DESC }

    # Paginate first
    first: Int = 20

    # Paginate last
    last: Int

    # Paginate after opaque cursor
    after: String

    # Paginate before opaque cursor
    before: String

    # If this flag is true, it will only fetch active cycles
    active: Boolean

    # This key filters all queries to a given cadence
    cadence: Cadence
  ): TeamCyclesConnection
  objectives(
    # The ID of the node you want to filter in your query
    id: ID

    # Define the expected order for our connection edges
    order: DefaultOrderInput = { createdAt: DESC }

    # Paginate first
    first: Int = 20

    # Paginate last
    last: Int

    # Paginate after opaque cursor
    after: String

    # Paginate before opaque cursor
    before: String

    # If you set this argument to true or false it will only fetch active or non-active objectives. Leave it null if you want both
    active: Boolean

    # If you set this argument to a user id, it will fetch its objectives. Leave null if you want all objectives.
    ownerId: ID

    # If you set this argument with a team id, it will fetch team related objectives. Leave null if you want all goals or set the id to null if you want objectives without team id.
    teamId: ID
  ): TeamObjectivesConnection
  supportObjectives(
    # The ID of the node you want to filter in your query
    id: ID

    # Define the expected order for our connection edges
    order: DefaultOrderInput = { createdAt: DESC }

    # Paginate first
    first: Int = 20

    # Paginate last
    last: Int

    # Paginate after opaque cursor
    after: String

    # Paginate before opaque cursor
    before: String

    # If you set this argument to true or false it will only fetch active or non-active objectives. Leave it null if you want both
    active: Boolean

    # If you set this argument to a user id, it will fetch its objectives. Leave null if you want all objectives.
    ownerId: ID

    # If you set this argument with a team id, it will fetch team related objectives. Leave null if you want all goals or set the id to null if you want objectives without team id.
    teamId: ID
  ): TeamObjectivesConnection
  allObjectives(
    # The ID of the node you want to filter in your query
    id: ID

    # Define the expected order for our connection edges
    order: DefaultOrderInput = { createdAt: DESC }

    # Paginate first
    first: Int = 20

    # Paginate last
    last: Int

    # Paginate after opaque cursor
    after: String

    # Paginate before opaque cursor
    before: String

    # If you set this argument to true or false it will only fetch active or non-active objectives. Leave it null if you want both
    active: Boolean

    # If you set this argument to a user id, it will fetch its objectives. Leave null if you want all objectives.
    ownerId: ID

    # If you set this argument with a team id, it will fetch team related objectives. Leave null if you want all goals or set the id to null if you want objectives without team id.
    teamId: ID
  ): TeamObjectivesConnection
  keyResults(
    # The user ID that should owns the key results you are trying to fetch
    ownerId: ID

    # Define the expected order for our connection edges
    order: DefaultOrderInput = { createdAt: DESC }

    # The ID of the node you want to filter in your query
    id: ID

    # Paginate first
    first: Int = 20

    # Paginate last
    last: Int

    # Paginate after opaque cursor
    after: String

    # Paginate before opaque cursor
    before: String

    # A flag that defines if we should fetch only active key-results for this user
    active: Boolean = true

    # A flag that defines if we should fetch only key-results that contains checkmarks of this user
    hasUserCheckMarks: Boolean

    # Define the confidence of the key results
    confidence: String

    # A flag that defines if we should fetch only key-results from a company
    onlyKeyResultsFromCompany: Boolean
  ): TeamKeyResultsConnection
}

# Each gender represents a possible gender option for our teams
enum TeamGender {
  MALE
  FEMALE
  NEUTRAL
}

# Data that you can assign to a given cycle
input CycleAttributesInput {
  # The period of the cycle
  period: String

  # The candence of this cycle. Cadence is the frequency at which previous objectives have to be grade and new ones created.
  cadence: Cadence

  # This flag defines if objectives related to this cycle can be updated
  active: Boolean

  # The date that this cycle starts
  dateStart: DateTime

  # The date that this cycle ends
  dateEnd: DateTime

  # The last update date of this cycle
  updatedAt: DateTime

  # The team ID that this cycle belongs to
  teamId: ID

  # Each cycle can relates with a given higher cycle, creating a for of tree-like architecture. If this cycle has any cycle above it, the ID of that will be recorded here
  parentId: ID
}

# Each cadence represents a period of time in which your cycles can be created
enum Cadence {
  YEARLY
  QUARTERLY
}

# Defines the expected options for user sorting
input UserOrderInput {
  # Defines the expected order for the firstName attribute
  firstName: Sorting
}

# The edge for our objective query interface
type ObjectiveRootEdge implements EdgeInterface {
  # The cursor value of this node
  cursor: String
  node: Objective!
}

# A list containing objectives based on the provided filters and arguments
type ObjectivesConnection implements ConnectionInterface & GuardedConnectionInterface {
  pageInfo: PageInfo!
  parentNodeId: ID!
  policy: ConnectionPolicy!
  edges: [ObjectiveRootEdge!]!
}

# This edge represents the relation between cycles and their key-results
type CycleKeyResultEdge implements EdgeInterface {
  # The cursor value of this node
  cursor: String
  node: KeyResult!
}

# A list containing a given user key-results based on the provided filters and arguments
type CycleKeyResultsConnection implements ConnectionInterface & GuardedConnectionInterface {
  pageInfo: PageInfo!
  parentNodeId: ID!
  policy: ConnectionPolicy!
  edges: [CycleKeyResultEdge!]!
}

# A collection of users. It can be either inside another team, or a root team (a.k.a. company)
type Cycle implements NodeInterface & GuardedNodeInterface {
  # The ID of this node
  id: ID!

  # The creation date of the entity
  createdAt: DateTime!
  policy: NodePolicy!

  # The period of the cycle
  period: String!

  # The candence of this cycle. Cadence is the frequency at which previous objectives have to be grade and new ones created.
  cadence: Cadence!

  # This flag defines if objectives related to this cycle can be updated
  active: Boolean!

  # The date that this cycle starts
  dateStart: DateTime!

  # The date that this cycle ends
  dateEnd: DateTime!

  # The last update date of this cycle
  updatedAt: DateTime!

  # The team ID that this cycle belongs to
  teamId: ID!

  # Each cycle can relates with a given higher cycle, creating a for of tree-like architecture. If this cycle has any cycle above it, the ID of that will be recorded here
  parentId: ID
  status(
    # Defines until with date we should look to define the status
    date: DateTime
  ): Status!
  delta: Delta!
  team: Team!
  parent: Cycle
  cycles(
    # The ID of the node you want to filter in your query
    id: ID

    # Define the expected order for our connection edges
    order: DefaultOrderInput = { createdAt: DESC }

    # Paginate first
    first: Int = 20

    # Paginate last
    last: Int

    # Paginate after opaque cursor
    after: String

    # Paginate before opaque cursor
    before: String

    # If this flag is true, it will only fetch active cycles
    active: Boolean

    # This key filters all queries to a given cadence
    cadence: Cadence
  ): CycleCyclesConnection
  objectives(
    # The ID of the node you want to filter in your query
    id: ID

    # Define the expected order for our connection edges
    order: DefaultOrderInput = { createdAt: DESC }

    # Paginate first
    first: Int = 20

    # Paginate last
    last: Int

    # Paginate after opaque cursor
    after: String

    # Paginate before opaque cursor
    before: String

    # If you set this argument to true or false it will only fetch active or non-active objectives. Leave it null if you want both
    active: Boolean

    # If you set this argument to a user id, it will fetch its objectives. Leave null if you want all objectives.
    ownerId: ID

    # If you set this argument with a team id, it will fetch team related objectives. Leave null if you want all goals or set the id to null if you want objectives without team id.
    teamId: ID
  ): ObjectivesConnection
  keyResults(
    # The ID of the node you want to filter in your query
    id: ID

    # Define the expected order for our key-result edges
    order: DefaultOrderInput = { createdAt: ASC }

    # Paginate first
    first: Int = 20

    # Paginate last
    last: Int

    # Paginate after opaque cursor
    after: String

    # Paginate before opaque cursor
    before: String

    # The user ID that should owns the key results you are trying to fetch
    ownerId: ID
  ): CycleKeyResultsConnection
}

# This edge represents the relation between cycles and their users
type CycleCycleEdge implements EdgeInterface {
  # The cursor value of this node
  cursor: String
  node: Cycle!
}

# A list containing a given cycle key-results based on the provided filters and arguments
type CycleCyclesConnection implements ConnectionInterface & GuardedConnectionInterface {
  pageInfo: PageInfo!
  parentNodeId: ID!
  policy: ConnectionPolicy!
  edges: [CycleCycleEdge!]!
}

# The edge for our cycle query interface
type CycleRootEdge implements EdgeInterface {
  # The cursor value of this node
  cursor: String
  node: Cycle!
}

# A list containing cycles based on the provided filters and arguments
type CyclesConnection implements ConnectionInterface & GuardedConnectionInterface {
  pageInfo: PageInfo!
  parentNodeId: ID!
  policy: ConnectionPolicy!
  edges: [CycleRootEdge!]!
}

# The delete result from a delete mutation
type DeleteResult {
  # The amount of entities removed
  affected: Int!
}

# The edge for our key-result comment query interface
type KeyResultCheckInRootEdge implements EdgeInterface {
  # The cursor value of this node
  cursor: String
  node: KeyResultCheckIn!
}

# A list containing key-result comments based on the provided filters and arguments
type KeyResultCheckInsConnection implements ConnectionInterface & GuardedConnectionInterface {
  pageInfo: PageInfo!
  parentNodeId: ID!
  policy: ConnectionPolicy!
  edges: [KeyResultCheckInRootEdge!]!
}

# The edge for our key-result comment query interface
type KeyResultCommentRootEdge implements EdgeInterface {
  # The cursor value of this node
  cursor: String
  node: KeyResultComment!
}

# A list containing key-result comments based on the provided filters and arguments
type KeyResultCommentsConnection implements ConnectionInterface & GuardedConnectionInterface {
  pageInfo: PageInfo!
  parentNodeId: ID!
  policy: ConnectionPolicy!
  edges: [KeyResultCommentRootEdge!]!
}

# The edge for our key-result query interface
type KeyResultRootEdge implements EdgeInterface {
  # The cursor value of this node
  cursor: String
  node: KeyResult!
}

# A list containing key-results based on the provided filters and arguments
type KeyResultsConnection implements ConnectionInterface & GuardedConnectionInterface {
  pageInfo: PageInfo!
  parentNodeId: ID!
  policy: ConnectionPolicy!
  edges: [KeyResultRootEdge!]!
}

type QuantityNode {
  keyResultsQuantity: Float!
  objectivesQuantity: Float!
  high: Float!
  medium: Float!
  low: Float!
  barrier: Float!
}

# The edge for our user query interface
type UserRootEdge implements EdgeInterface {
  # The cursor value of this node
  cursor: String
  node: User!
}

# A list containing users based on the provided filters and arguments
type UsersConnection implements ConnectionInterface & GuardedConnectionInterface {
  pageInfo: PageInfo!
  parentNodeId: ID!
  policy: ConnectionPolicy!
  edges: [UserRootEdge!]!
}

# An object continaing the progress of a user in a specific cycle type and rather to show it or not
type UserReportProgressObject {
  showProgress: Boolean!
  progress: Float!
}

# An object continaing the role of the user in the auth0 system.
type UserRoleObject {
  id: String
  name: String
  description: String
}

# The edge for our team query interface
type TeamRootEdge implements EdgeInterface {
  # The cursor value of this node
  cursor: String
  node: Team!
}

# A list containing teams based on the provided filters and arguments
type TeamsConnection implements ConnectionInterface & GuardedConnectionInterface {
  pageInfo: PageInfo!
  parentNodeId: ID!
  policy: ConnectionPolicy!
  edges: [TeamRootEdge!]!
}

type Query {
  permissions(scope: Scope = COMPANY): Permissions!
  user(
    # The ID of the node you want to get in your query
    id: ID
  ): User!
  me: User!
  userUserSetting(
    # The ID of the node you want to get in your query
    id: ID
  ): UserSetting!
  users(
    # The ID of the node you want to filter in your query
    id: ID

    # Define the expected order for our users connection edges
    order: UserOrderInput = { firstName: ASC }

    # Paginate first
    first: Int = 20

    # Paginate last
    last: Int

    # Paginate after opaque cursor
    after: String

    # Paginate before opaque cursor
    before: String

    # Define if the query should return only users with individual objectives
    onlyWithIndividualObjectives: Boolean

    # Define if the query should return only active users or not
    withInactives: Boolean
  ): UsersConnection!
  team(
    # The ID of the node you want to get in your query
    id: ID
  ): Team!
  teams(
    # The ID of the node you want to filter in your query
    id: ID

    # Define the expected order for our connection edges
    order: DefaultOrderInput = { createdAt: DESC }

    # Paginate first
    first: Int = 20

    # Paginate last
    last: Int

    # Paginate after opaque cursor
    after: String

    # Paginate before opaque cursor
    before: String

    # The ID of the parent team that you want to user on this query
    parentId: ID

    # Defines the level of the team you want to query
    level: TeamType
  ): TeamsConnection!
  keyResult(
    # The ID of the node you want to get in your query
    id: ID
  ): KeyResult!
  keyResultComment(
    # The ID of the node you want to get in your query
    id: ID
  ): KeyResultComment!
  keyResultCheckIn(
    # The ID of the node you want to get in your query
    id: ID
  ): KeyResultCheckIn!
  keyResultCheckIns(
    # The ID of the node you want to filter in your query
    id: ID

    # Define the expected order for our connection edges
    order: DefaultOrderInput = { createdAt: DESC }

    # Paginate first
    first: Int = 20

    # Paginate last
    last: Int

    # Paginate after opaque cursor
    after: String

    # Paginate before opaque cursor
    before: String

    # Fetches key-result comments from a given user
    userId: ID
  ): KeyResultCheckInsConnection!
  keyResults(
    # The ID of the node you want to filter in your query
    id: ID

    # Define the expected order for our key-result edges
    order: DefaultOrderInput = { createdAt: ASC }

    # Paginate first
    first: Int = 20

    # Paginate last
    last: Int

    # Paginate after opaque cursor
    after: String

    # Paginate before opaque cursor
    before: String

    # The user ID that should owns the key results you are trying to fetch
    ownerId: ID
  ): KeyResultsConnection!
  keyResultComments(
    # The ID of the node you want to filter in your query
    id: ID

    # Define the expected order for our connection edges
    order: DefaultOrderInput = { createdAt: DESC }

    # Paginate first
    first: Int = 20

    # Paginate last
    last: Int

    # Paginate after opaque cursor
    after: String

    # Paginate before opaque cursor
    before: String

    # Fetches key-result comments from a given user
    userId: ID
  ): KeyResultCommentsConnection!
  objective(
    # The ID of the node you want to get in your query
    id: ID
  ): Objective!
  objectives(
    # The ID of the node you want to filter in your query
    id: ID

    # Define the expected order for our connection edges
    order: DefaultOrderInput = { createdAt: DESC }

    # Paginate first
    first: Int = 20

    # Paginate last
    last: Int

    # Paginate after opaque cursor
    after: String

    # Paginate before opaque cursor
    before: String

    # If you set this argument to true or false it will only fetch active or non-active objectives. Leave it null if you want both
    active: Boolean

    # If you set this argument to a user id, it will fetch its objectives. Leave null if you want all objectives.
    ownerId: ID

    # If you set this argument with a team id, it will fetch team related objectives. Leave null if you want all goals or set the id to null if you want objectives without team id.
    teamId: ID
  ): ObjectivesConnection!
  cycle(
    # The ID of the node you want to get in your query
    id: ID
  ): Cycle!
  cyclesInSamePeriod(
    # If this flag is true, it will only fetch active cycles
    active: Boolean

    # This key filters all queries to a given cadence
    cadence: Cadence

    # The ID of the node you want to filter in your query
    id: ID

    # Define the expected order for our connection edges
    order: DefaultOrderInput = { createdAt: DESC }

    # Paginate first
    first: Int = 20

    # Paginate last
    last: Int

    # Paginate after opaque cursor
    after: String

    # Paginate before opaque cursor
    before: String

    # Defines a list of cycle IDs we are going to fetch from
    fromCycles: [ID!]!
  ): CyclesConnection!
  cycles(
    # The ID of the node you want to filter in your query
    id: ID

    # Define the expected order for our connection edges
    order: DefaultOrderInput = { createdAt: DESC }

    # Paginate first
    first: Int = 20

    # Paginate last
    last: Int

    # Paginate after opaque cursor
    after: String

    # Paginate before opaque cursor
    before: String

    # If this flag is true, it will only fetch active cycles
    active: Boolean

    # This key filters all queries to a given cadence
    cadence: Cadence
  ): CyclesConnection!
  workspace(
    # The ID of the node you want to get in your query
    id: ID
  ): Workspace!
}

# An authorization scope for your resource. It defines the level of permission that the resource needs
enum Scope {
  ANY
  COMPANY
  TEAM
  OWNS
}

type Mutation {
  updateUser(id: ID!, data: UserUpdateInput!): User!
  deactivateUser(id: ID!): User!
  reactivateUser(id: ID!): User!
  createUser(data: UserCreateInput!): User!
  updateUserRole(id: ID!, role: String!): User
  requestChangeUserPasswordEmail(id: ID!): User
  createTask(
    # The ID of the node you want to filter in your query
    id: ID

    # Define the expected order for our connection edges
    order: DefaultOrderInput = { createdAt: DESC }

    # Paginate first
    first: Int = 20

    # Paginate last
    last: Int

    # Paginate after opaque cursor
    after: String

    # Paginate before opaque cursor
    before: String

    # The description of the task being created
    description: String!
  ): Task!
  toggleTask(
    # The id of the task
    id: ID!

    # Define the expected order for our connection edges
    order: DefaultOrderInput = { createdAt: DESC }

    # Paginate first
    first: Int = 20

    # Paginate last
    last: Int

    # Paginate after opaque cursor
    after: String

    # Paginate before opaque cursor
    before: String
  ): Task!
  deleteTask(
    # The id of the task
    id: ID!

    # Define the expected order for our connection edges
    order: DefaultOrderInput = { createdAt: DESC }

    # Paginate first
    first: Int = 20

    # Paginate last
    last: Int

    # Paginate after opaque cursor
    after: String

    # Paginate before opaque cursor
    before: String
  ): DeleteResult!
  updateTaskDescription(
    # The Id of the task to be updated
    id: ID

    # Define the expected order for our connection edges
    order: DefaultOrderInput = { createdAt: DESC }

    # Paginate first
    first: Int = 20

    # Paginate last
    last: Int

    # Paginate after opaque cursor
    after: String

    # Paginate before opaque cursor
    before: String

    # The description new description of the task
    description: String
  ): Task!
  updateUserSetting(
    # The ID of the user you are updating settings
    userID: ID!

    # A specific key you want to change user settings
    key: UserSettingKey!

    # The value of the new setting
    value: String!
  ): UserSetting!
  addTeamToUser(userID: ID!, teamID: ID!): User!
  removeTeamFromUser(userID: ID!, teamID: ID!): User!
  createTeam(data: TeamCreateInput!): Team!
  updateKeyResult(id: ID!, data: KeyResultAttributesInput!): KeyResult!
  createKeyResult(data: KeyResultInput!): KeyResult!
  deleteKeyResult(id: ID!): DeleteResult!
  createKeyResultComment(data: KeyResultCommentInput!): KeyResultComment!
  deleteKeyResultComment(
    # The ID of the key-result comment you want to delete
    id: ID!
  ): DeleteResult!
  createKeyResultCheckMark(data: KeyResultCheckMarkInput!): KeyResultCheckMark!
  toggleCheckMark(data: KeyResultCheckMarkToggleInput!): KeyResultCheckMark!
  updateCheckMarkDescription(
    id: ID!
    data: KeyResultCheckMarkUpdateDescriptionInput!
  ): KeyResultCheckMark!
  updateCheckMarkAssignee(
    id: ID!
    data: KeyResultCheckMarkUpdateAssigneeInput!
  ): KeyResultCheckMark!
  deleteCheckMark(id: ID!): DeleteResult!
  createKeyResultCheckIn(data: KeyResultCheckInInput!): KeyResultCheckIn!
  deleteKeyResultCheckIn(
    # The ID of the key-result check-in you want to delete
    id: ID!
  ): DeleteResult!
  addUserAsSupportTeamToKeyResult(
    data: KeyResultAddUserToSupportTeamInput!
  ): KeyResult!
  removeUserAsSupportTeamToKeyResult(
    data: KeyResultRemoveUserToSupportTeamInput!
  ): KeyResult!
  updateObjective(id: ID!, data: ObjectiveAttributesInput!): Objective!
  deleteObjective(id: ID!): DeleteResult!
  createObjective(data: ObjectiveInput!): Objective!
  createCycle(data: CycleInput!): Cycle!
  updateCycle(id: ID!, data: CycleAttributesInput!): Cycle!
  deleteCycle(id: ID!): DeleteResult!
  createWorkspace(data: WorkspaceCreateInput!): Workspace!
}

# Data that you can assign to a given user while updating it
input UserUpdateInput {
  # The first name of the user
  firstName: String

  # The last name of the user
  lastName: String

  # An image file that we will upload and user as the new user picture
  picture: Upload

  # The role of the user in her/his company
  role: String

  # The custom nickname that user wants to be called
  nickname: String

  # A description for that user. A more detailed information where the user tells about her/himself
  about: String

  # The URL for the user's LinkedIn profile
  linkedInProfileAddress: String

  # The gender of the user
  gender: UserGender

  # The new e-mail for the user
  email: String
}

scalar Upload

# Data that you need to provide while creating a new user
input UserCreateInput {
  # The first name of the user
  firstName: String!

  # The last name of the user
  lastName: String!

  # The role of the user in her/his company
  role: String

  # The gender of the user
  gender: UserGender!

  # The e-mail for the user
  email: String!

  # The ID of the primary team for this user
  teamID: ID!

  # The locale for this user
  locale: String
}

# Data that you need to provide while creating a new user
input TeamCreateInput {
  # The name of the team
  name: String!

  # The description of the team
  description: String!

  # The description of the team
  gender: TeamGender!

  # The user id of the team owner
  ownerID: ID!

  # The id of the parent team
  parentID: ID!
}

# Data that you can assign to a given key-result
input KeyResultAttributesInput {
  # The title of the key result
  title: String

  # The initial value of the key result
  initialValue: Float

  # The goal of the key result
  goal: Float

  # The owner ID of the key result
  ownerId: ID

  # The object ID that this key result belongs to
  objectiveId: ID

  # The team ID that this key result belongs to
  teamId: ID

  # The description explaining the key result
  description: String
}

# Data required to create a new Key Result
input KeyResultInput {
  # The title of the key result
  title: String!

  # The initial value of the key result
  initialValue: Float!

  # The goal of the key result
  goal: Float!

  # The format of the key result
  format: KeyResultFormat!

  # The type of the key result
  type: KeyResultType = ASCENDING

  # The owner ID of the key result
  ownerId: ID!

  # The object ID that this key result belongs to
  objectiveId: ID!

  # The team ID that this key result belongs to
  teamId: ID

  # The description explaining the key result
  description: String
}

# The required data to create a new comment
input KeyResultCommentInput {
  # The text of the comment
  text: String!

  # The key result ID related to this comment
  keyResultId: ID!
}

# The required data to create a new check mark
input KeyResultCheckMarkInput {
  # The description of the check mark
  description: String!

  # The key result ID related to this check mark
  keyResultId: ID!
}

# The required data to toggle a check mark
input KeyResultCheckMarkToggleInput {
  # The ID of the check mark
  id: ID!
}

# The required data to update a check mark description
input KeyResultCheckMarkUpdateDescriptionInput {
  # The new description of the check mark
  description: String!
}

# The required data to update a check mark assigned user
input KeyResultCheckMarkUpdateAssigneeInput {
  # The new user id to assign the check mark
  assignedUserId: ID!
}

# The required data to create a new check-in
input KeyResultCheckInInput {
  # The check-in value you are reporting
  value: Float!

  # The confidence value you are reporting
  confidence: Int!

  # The key result ID related to this report
  keyResultId: ID!

  # The comment in your check-in
  comment: String
}

# Data required to add a user to support team
input KeyResultAddUserToSupportTeamInput {
  # The id of the key result
  keyResultId: ID!

  # The id of the user to be added
  userId: ID!
}

# Data required to remove a user to support team
input KeyResultRemoveUserToSupportTeamInput {
  # The id of the key result
  keyResultId: ID!

  # The id of the user to be removed
  userId: ID!
}

# Data that you can assign to a given objective
input ObjectiveAttributesInput {
  # The title of the objective
  title: String

  # The ID of the cycle for that objective
  cycleId: ID

  # The ID of the owner for the cycle
  ownerId: ID

  # The main team of that objective
  teamId: ID
}

# The required data to create a new objective
input ObjectiveInput {
  # The title of the objective
  title: String!

  # The ID of the cycle for that objective
  cycleId: ID!

  # The ID of the owner for the cycle
  ownerId: ID!

  # The main team of that objective
  teamId: ID
}

# Data required to create a new Cycle
input CycleInput {
  # The title of the cycle
  period: String!

  # The cadence of the cycle
  cadence: Cadence!

  # The type of the cycle
  active: Boolean!

  # The start date of the cycle
  dateStart: DateTime!

  # The end date of the cycle
  dateEnd: DateTime!

  # The team ID that this cycle belongs to
  teamId: ID!

  # The parent cycle ID of this cycle
  parentId: String
}

# Data that you need to provide while creating a new workspace
input WorkspaceCreateInput {
  # The root team data of the workspace
  team: WorkspaceTeamCreateInput!

  # The root user of the workspace
  user: WorkspaceRootUserCreateInput!

  # The initial yearly cycle of the workspace
  yearlyCycle: WorkspaceCycleCreateInput!

  # The initial quarterly cycle of the workspace
  quarterlyCycle: WorkspaceCycleCreateInput!

  # Options to customize the workspace creation
  options: WorkspaceCreateOptions = { autoInvite: true }
}

# Data that you need to provide while creating a new team
input WorkspaceTeamCreateInput {
  # The name of the team
  name: String!

  # The description of the team
  description: String

  # The description of the team
  gender: TeamGender
}

# Data that you need to provide while creating a new root user for a new workspace
input WorkspaceRootUserCreateInput {
  # The first name of the user
  firstName: String!

  # The last name of the user
  lastName: String!

  # The role of the user in her/his company
  role: String

  # The gender of the user
  gender: UserGender!

  # The e-mail for the user
  email: String!

  # The locale for this user
  locale: String
}

# Data that you need to provide while creating a new cycle
input WorkspaceCycleCreateInput {
  # The period of that cycle
  period: String!

  # The date that this cycle starts
  dateStart: DateTime!

  # The date that this cycle ends
  dateEnd: DateTime!
}

# Options to customize your workspace creation
input WorkspaceCreateOptions {
  # Define if we should automatically invite the new root user
  autoInvite: Boolean
}
